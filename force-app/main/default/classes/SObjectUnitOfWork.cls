/**
 * Copyright (c) 2012, FinancialForce.com, inc
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, 
 *   are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, 
 *      this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, 
 *      this list of conditions and the following disclaimer in the documentation 
 *      and/or other materials provided with the distribution.
 * - Neither the name of the FinancialForce.com, inc nor the names of its contributors 
 *      may be used to endorse or promote products derived from this software without 
 *      specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL 
 *  THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 *  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**/

/**
 * Provides an implementation of the Enterprise Application Architecture Unit Of Work, as defined by Martin Fowler
 *   http://martinfowler.com/eaaCatalog/unitOfWork.html
 *
 * "When you're pulling data in and out of a database, it's important to keep track of what you've changed; otherwise, 
 *  that data won't be written back into the database. Similarly you have to insert new objects you create and 
 *  remove any objects you delete."
 *
 * "You can change the database with each change to your object model, but this can lead to lots of very small database calls, 
 *  which ends up being very slow. Furthermore it requires you to have a transaction open for the whole interaction, which is 
 *  impractical if you have a business transaction that spans multiple requests. The situation is even worse if you need to
 *  keep track of the objects you've read so you can avoid inconsistent reads."
 *
 * "A Unit of Work keeps track of everything you do during a business transaction that can affect the database. When you're done, 
 *  it figures out everything that needs to be done to alter the database as a result of your work."
 *
 * In an Apex context this pattern provides the following specific benifits
 *  - Applies bulkfication to DML operations, insert, update and delete
 *  - Manages a business transaction around the work and ensures a rollback occurs (even when exceptions are later handled by the caller)
 *  - Honours dependency rules between records and updates dependent relationships automatically during the commit 
 *
 * Please refer to the testMethod's in this class for example usage 
 *
 * TODO: Need to complete the 100% coverage by covering parameter exceptions in tests
 * TODO: Need to add some more test methods for more complex use cases and some unexpected (e.g. registerDirty and then registerDeleted)
 *
 *Modification Log :
 *-----------------------------------------------------------------------------
 * Developer                   Date                   Description
 * ----------------------------------------------------------------------------                 
 * 
**/
public without sharing class SObjectUnitOfWork
{
    private List<Schema.SObjectType> m_sObjectTypes = new List<Schema.SObjectType>();
    
    private Map<String, List<SObject>> m_newListByType = new Map<String, List<SObject>>();

    protected Map<String, Map<Id, SObject>> m_dirtyMapByType = new Map<String, Map<Id, SObject>>();
    
    private Map<String, List<SObject>> m_deletedListByType = new Map<String, List<SObject>>();
    
    private Map<String, Relationships> m_relationships = new Map<String, Relationships>();
    
    /**
     * Constructs a new UnitOfWork to support work against the given object list
     *
     * @param sObjectList A list of objects given in dependency order (least dependent first)
     */
    public SObjectUnitOfWork(List<Schema.SObjectType> sObjectTypes)
    {
        addObjectTypes(sObjectTypes);
    }
    
    /**
    *
    * Constructor
    *
    */  
    public SObjectUnitOfWork() {
        
    }
    

    /**
     * Add supported object list
     *
     * @param sObjectList A list of objects given in dependency order (least dependent first)
     */ 
    public void addObjectTypes(List<Schema.SObjectType> sObjectTypes)
    {
        if (sObjectTypes<>null) {       
        
            m_sObjectTypes.addAll(sObjectTypes);
            
            for(Schema.SObjectType sObjectType : sObjectTypes)
            {
                if (!m_newListByType.containsKey(sObjectType.getDescribe().getName()))
                    m_newListByType.put(sObjectType.getDescribe().getName(), new List<SObject>());
                if (!m_dirtyMapByType.containsKey(sObjectType.getDescribe().getName())) //Ashwan
                    m_dirtyMapByType.put(sObjectType.getDescribe().getName(), new Map<Id, SObject>());
                if (!m_deletedListByType.containsKey(sObjectType.getDescribe().getName()))
                    m_deletedListByType.put(sObjectType.getDescribe().getName(), new List<SObject>());
                if (!m_relationships.containsKey(sObjectType.getDescribe().getName()))
                    m_relationships.put(sObjectType.getDescribe().getName(), new Relationships());  
            }
        }
    }
    
    /**
     * Register a newly created SObject instance to be inserted when commitWork is called
     *
     * @param record A newly created SObject instance to be inserted during commitWork
     **/
    public void registerNew(SObject record)
    {
        registerNew(record, null, null);
    }
    
    /**
     * Register a list of newly created SObject instances to be inserted when commitWork is called
     *
     * @param record A List of newly created SObject instances to be inserted during commitWork
     **/
    public void registerNew(List<SObject> records)
    {
        if(records != null)
        {
            for(SObject record : records)
            {
                registerNew(record);
            }
        }
    }

    public void registerNew(SObject record, Schema.sObjectField relatedToParentField, SObject relatedToParentRecord) {
        registerNew(record, relatedToParentField, relatedToParentRecord, 'Child');        
    }

    /**
     * Register a newly created SObject instance to be inserted when commitWork is called, 
     *   you may also provide a reference to the parent record instance (should also be registered as new separatly)
     *
     * @param record A newly created SObject instance to be inserted during commitWork
     * @param relatedToParentField A SObjectField reference to the child field that associates the child record with its parent
     * @param relatedToParentRecord A SObject instance of the parent record (should also be registered as new separatly)
     **/
    public void registerNew(SObject record, Schema.sObjectField relatedToParentField, SObject relatedToParentRecord, String relType)
    {
        if(record.Id != null)
            throw new UnitOfWorkException('Only new records can be registered as new');
        String sObjectType = record.getSObjectType().getDescribe().getName();           
        if(!m_newListByType.containsKey(sObjectType))
            throw new UnitOfWorkException(String.format('SObject type {0} is not supported by this unit of work', new String[] { sObjectType }));
        m_newListByType.get(sObjectType).add(record);               
        if(relatedToParentRecord!=null && relatedToParentField!=null)
            registerRelationship(record, relatedToParentField, relatedToParentRecord,relType);
    }

    
    public void registerRelationship(SObject record, Schema.sObjectField relatedToField, SObject relatedTo) {
        registerRelationship(record, relatedToField, relatedTo, 'Child');
    }

    /**
     * Register a relationship between two records that have yet to be inserted to the database. This information will be 
     *  used during the commitWork phase to make the references only when related records have been inserted to the database.
     *
     * @param record An existing or newly created record
     * @param relatedToField A SObjectField referene to the lookup field that relates the two records together
     * @param relatedTo A SOBject instance (yet to be commited to the database)
     */    
    public void registerRelationship(SObject record, Schema.sObjectField relatedToField, SObject relatedTo, String type)
    {
        String sObjectType = record.getSObjectType().getDescribe().getName();       
        if(!m_newListByType.containsKey(sObjectType))
            throw new UnitOfWorkException(String.format('SObject type {0} is not supported by this unit of work', new String[] { sObjectType }));
        m_relationships.get(sObjectType).add(record, relatedToField, relatedTo,type);
    }
    /**
     * Register an existing record to be updated during the commitWork method
     *
     * @param record An existing record
     **/
    public void registerDirty(SObject record, List<Schema.SobjectField> listOfDirtyFields, String SObjectType)
    {
        if (record.Id == null)
            throw new UnitOfWorkException('New records cannot be registered as dirty');            
            if (!m_dirtyMapByType.get(sObjectType).containsKey(record.Id))
        {
            // Register the record as dirty
            m_dirtyMapByType.get(sObjectType).put(record.Id, record);
        }else{
            if(listOfDirtyFields != null && listOfDirtyFields.size() > 0){
               // Update the registered record's fields
                SObject registeredRecord = m_dirtyMapByType.get(sObjectType).get(record.Id);
                for (Schema.SobjectField fieldName : listOfDirtyFields) {
                    if(fieldName.getDescribe().isUpdateable())
                        registeredRecord.put(fieldName, record.get(fieldName));
                }
                m_dirtyMapByType.get(sObjectType).put(record.Id, registeredRecord); 
            }
    	}
    }
	
     /**
     * Generates dirty SObjectFields
     *
     * @param list of SObjectType and and Map of dirty fields
     **/
    public void registerDirty(List<SObject> records, Map<String, List<Schema.SobjectField>> mapOfDirtyFields)
    {
        List<Schema.SobjectField> listOfDirtyFields = New List<Schema.SobjectField>();
        if(records != null && mapOfDirtyFields.size() > 0)
        {
            for(SObject record : records)
            {
                String sObjectType = record.getSObjectType().getDescribe().getName();
                listOfDirtyFields = mapOfDirtyFields.get(sObjectType);
                registerDirty(record, listOfDirtyFields, sObjectType);
            }
        }
    }
    
     /**Refactored
     * Generates dirty SObjectFields
     *
     * @param SObjectType and and list of dirty fields in string format
     **/
    public void registerDirty(List<SObject> records, String SObjectType, List<String> fieldNames){
        
        List<Schema.SobjectField> listOfDirtyFields = New List<Schema.SobjectField>();
        Map<String, Schema.SObjectField> mapOfSObjectFields= New Map<String, Schema.SObjectField>();
        Map<String, List<Schema.SobjectField>> mapOfSObjecTypeAndDirtyFields = New Map<String, List<Schema.SobjectField>>();
        if(!mapOfSObjectFields.containsKey(SObjectType)){
            mapOfSObjectFields = Schema.getGlobalDescribe().get(sObjectType).getDescribe().fields.getMap();
        }
        if(mapOfSObjectFields.size() > 0 && fieldNames.size() > 0){
            for(String fieldName : fieldNames){
                if(mapOfSObjecTypeAndDirtyFields.containsKey(sObjectType)){
                    mapOfSObjecTypeAndDirtyFields.get(sObjectType).add(mapOfSObjectFields.get(fieldName));
                }else{
                    mapOfSObjecTypeAndDirtyFields.put(sObjectType, New List<Schema.SobjectField>{mapOfSObjectFields.get(fieldName)});
                }
            }
        }
        registerDirty(records, mapOfSObjecTypeAndDirtyFields);        
    }
    
    public void registerDeleted(List<SObject> records)
    {
        if(records != null)
        {
            for(SObject record : records)
            {
                registerDeleted(record);
            }
        }
    }
    
    /**
     * Register an existing record to be deleted during the commitWork method
     *
     * @param record An existing record
     **/
    public void registerDeleted(SObject record)
    {
        if(record.Id == null)
            throw new UnitOfWorkException('New records cannot be registered for deletion');
        String sObjectType = record.getSObjectType().getDescribe().getName();           
        if(!m_deletedListByType.containsKey(sObjectType))
            throw new UnitOfWorkException(String.format('SObject type {0} is not supported by this unit of work', new String[] { sObjectType }));
        m_deletedListByType.get(sObjectType).add(record);                           
    }
    
    /**
     * Takes all the work that has been registered with the UnitOfWork and commits it to the database
     **/
    public void commitWork()
    {
        // Wrap the work in its own transaction 
        Savepoint sp = Database.setSavePoint();     
        try
        {       
            // Insert by type
            for(Schema.SObjectType sObjectType : m_sObjectTypes)
            {
                m_relationships.get(sObjectType.getDescribe().getName()).resolve();
                system.debug('==========Insert>>' + m_newListByType.get(sObjectType.getDescribe().getName()));
                insert m_newListByType.get(sObjectType.getDescribe().getName());                
                system.debug('==========Insert Success>>' + m_newListByType.get(sObjectType.getDescribe().getName()));
                m_relationships.get(sObjectType.getDescribe().getName()).updateChild();
            }                   
            // Update by type
            for(Schema.SObjectType sObjectType : m_sObjectTypes) {

                system.debug('==========Update>>' + m_dirtyMapByType.get(sObjectType.getDescribe().getName()));            
                update m_dirtyMapByType.get(sObjectType.getDescribe().getName()).values();      
                system.debug('==========Update Success>>' + m_dirtyMapByType.get(sObjectType.getDescribe().getName()));       
            }
            // Delete by type (in reverse dependency order)
            Integer objectIdx =m_sObjectTypes.size() - 1;
            while(objectIdx>=0){
                Integer curIndex = objectIdx;
                system.debug('==========Delete>>' + m_deletedListByType.get(m_sObjectTypes[curIndex ].getDescribe().getName()));            
                delete m_deletedListByType.get(m_sObjectTypes[curIndex ].getDescribe().getName());
                system.debug('==========Delete Success>>' + m_deletedListByType.get(m_sObjectTypes[curIndex ].getDescribe().getName()));
                objectIdx--;
            }
            
            ClearLists();
        }
        catch (Exception e)
        {
            // PR Team
			/*Exception_Log__e expLog = new Exception_Log__e();
            expLog.Class_Name__c = 'SObjectUnitOfWork';
            expLog.Method_Name__c = 'commitWork';
            expLog.Error_Message__c = e.getMessage();
            expLog.Stack_Trace__c =  e.getStackTraceString();
            EventBus.publish(expLog);*/
            //Ends here
            
            // Rollback
            Database.rollback(sp);
            // Throw exception on to caller
            throw e;
        }
    }
    
    Private void ClearLists() {
        // Clear all record Lists
        for(Schema.SObjectType sObjectType : m_sObjectTypes)
        {
            m_newListByType.get(sObjectType.getDescribe().getName()).clear();
            m_dirtyMapByType.get(sObjectType.getDescribe().getName()).clear();   
            m_deletedListByType.get(sObjectType.getDescribe().getName()).clear();      
        }                   
    }
    
    private class Relationships
    {
        private List<Relationship> m_relationships = new List<Relationship>();

        public void resolve()
        {
            // Resolve relationships
            for(Relationship relationship : m_relationships) {                
                if (relationship.Type=='Child') {
                    relationship.Record.put(relationship.RelatedToField, relationship.RelatedTo.Id);
                }
            }
        }
        
        public void updateChild()
        {
            // Resolve relationships
            for(Relationship relationship : m_relationships) {
                if (relationship.Type=='UpdateIDAfterIsert') {
                      System.Debug('####relationship.RelatedToField'+relationship.RelatedToField);
                        System.Debug('####relationship.Record.Id'+relationship.Record.Id);
                    relationship.RelatedTo.put(relationship.RelatedToField, relationship.Record.Id);
                }
            }
        }
        
        
        public void add(SObject record, Schema.sObjectField relatedToField, SObject relatedTo, String type)
        {
            // Relationship to resolve
            Relationship relationship = new Relationship();
            relationship.Record = record;
            relationship.RelatedToField = relatedToField;
            relationship.RelatedTo = relatedTo;
            relationship.Type = Type;
            m_relationships.add(relationship);
        }
    }
    
    private class Relationship
    {
        public SObject Record;
        public Schema.sObjectField RelatedToField;
        public SObject RelatedTo;
        public String Type;
    }
    
    /**
     * UnitOfWork Exception
     **/
    public class UnitOfWorkException extends Exception {}

    // SObjects (in order of dependency) used by UnitOfWork in tests bellow 
    private static List<Schema.SObjectType> MY_SOBJECTS = 
        new Schema.SObjectType[] { 
            Product2.SObjectType, 
            PricebookEntry.SObjectType, 
            Opportunity.SObjectType, 
            OpportunityLineItem.SObjectType };

        
            
    private static void assertResults(String prefix)
    {
        // Standard Assertions on tests data inserted by tests
        String filter = prefix + ' Test Name %';
        List<Opportunity> opps = [select Id, Name, (Select Id from OpportunityLineItems) from Opportunity where Name like :filter order by Name];
        System.assertEquals(10, opps.size());
        System.assertEquals(1, opps[0].OpportunityLineItems.size());        
        System.assertEquals(2, opps[1].OpportunityLineItems.size());        
        System.assertEquals(3, opps[2].OpportunityLineItems.size());        
        System.assertEquals(4, opps[3].OpportunityLineItems.size());        
        System.assertEquals(5, opps[4].OpportunityLineItems.size());        
        System.assertEquals(6, opps[5].OpportunityLineItems.size());        
        System.assertEquals(7, opps[6].OpportunityLineItems.size());        
        System.assertEquals(8, opps[7].OpportunityLineItems.size());        
        System.assertEquals(9, opps[8].OpportunityLineItems.size());        
        System.assertEquals(10, opps[9].OpportunityLineItems.size());       
    }

}